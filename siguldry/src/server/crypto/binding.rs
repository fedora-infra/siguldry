// SPDX-License-Identifier: MIT
// Copyright (c) Microsoft Corporation.

//! Functions for encrypting and decrypting key passwords.
//!
//! Keys stored in the database are encrypted using a password generated by Siguldry, and PKCS #11
//! modules are protected by a PIN. Both of these secrets are then encrypted using a combination of
//! user-provided secrets ("user passwords") and keys stored in PKCS#11 modules on the server
//! (examples include a Yubikey or TPM, but anything with a PKCS#11 module will work).
//!
//! This implementation was based of the one in the Sigul project.

use std::{
    io::{Read, Write},
    process::Stdio,
};

use anyhow::Context;
use openssl::{
    cms::{CMSOptions, CmsContentInfo},
    hash::MessageDigest,
    stack::Stack,
    symm::Cipher,
    x509::X509,
};
use sequoia_openpgp::{
    crypto::Password,
    parse::{
        Parse,
        stream::{DecryptionHelper, DecryptorBuilder, VerificationHelper},
    },
    policy::StandardPolicy,
    serialize::stream::{Armorer, Encryptor, LiteralWriter, Message},
    types::SymmetricAlgorithm,
};
use serde::{Deserialize, Serialize};

use crate::server::config::Pkcs11Binding;

/// The intermediate data format for passwords.
///
/// A key password, used to decrypt the actual signing key, never leaves the server. Instead,
/// it's encrypted using a set of server-side RSA keys which are stored in a PKCS#11 token,
/// which is then encrypted with a user's access password.
///
/// This is serialized to JSON, which looks like:
///
/// `{"None": {"password": "my-password"}}`
///
/// or
///
/// `{"Pkcs11": {"key_fingerprint": "hexencodedsha256sum", "password": "-----BEGIN PKCS7-----..." `
#[derive(Debug, Clone, Serialize, Deserialize)]
enum BoundPassword {
    /// No binding was used.
    None { password: String },
    /// Secrets bound by asymmetric keys stored in a device accessible via PKCS#11.
    ///
    /// Secrets of this variant have been encrypted using OpenSSL's CMS interface and the
    /// results are PEM-encoded.
    ///
    /// Examples of key stores include SoftHSMv2 or any HSM that provides a PKCS#11 interface,
    /// Yubikeys via the libykcs11 library, and Trusted Platform Modules (TPMs) via the
    /// libtpm2_pkcs11 library. Creating and managing the key pairs is up to the administrator.
    Pkcs11WithCMS {
        /// The SHA256 digest of the DER-encoded X509 certificate used in this binding.
        key_fingerprint: String,
        /// The key password that's been encrypted by the X509 certificate identified in
        /// `key_fingerprint`. The string contains a PEM-encoded CMS structure.
        password: String,
    },
}

// I think this is the JSON format used by sigul for pkcs11. It'll be a list for most entries,
// but some old ones are dictionaries. Additionally, sigul theoretically supports recursive
// binding but that does appear to actually be used. This structure will be useful for writing
// the migration script later.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[allow(dead_code)]
struct SigulPkcs11BoundPassword {
    method: String,
    value: String,
    token: String,
}

/// Decrypt a key password to enable access to the key itself.
pub async fn decrypt_key_password(
    bindings: &[Pkcs11Binding],
    user_password: Password,
    data: &[u8],
) -> anyhow::Result<Password> {
    let key_bindings: Vec<BoundPassword> = symmetric_decrypt(user_password, data)
        .map(|data| serde_json::from_slice(&data))
        .context("User password is invalid")?
        .map_err(|_e| anyhow::anyhow!("JSON content in database could not be deserialized!"))?;

    for bound_password in key_bindings {
        match bound_password {
            BoundPassword::None { password } => return Ok(Password::from(password)),
            BoundPassword::Pkcs11WithCMS {
                key_fingerprint,
                password,
            } => {
                for binding in bindings.iter().filter(|binding| binding.can_unbind()) {
                    if let Ok(password) =
                        binding_decrypt(binding.clone(), password.clone().into_bytes())
                            .await
                            .map(Password::from)
                    {
                        return Ok(password);
                    } else {
                        tracing::debug!(
                            certificate = key_fingerprint,
                            key_uri = binding.private_key,
                            "Failed to unbind key password"
                        );
                    }
                }
            }
        }
    }

    Err(anyhow::anyhow!("Unable to unbind key password"))
}

/// Encrypt a key password for storage.
pub fn encrypt_key_password(
    bindings: &[Pkcs11Binding],
    user_password: Password,
    key_password: Password,
) -> anyhow::Result<Vec<u8>> {
    let mut bound_passwords = bindings
        .iter()
        .map(|binding| {
            tracing::info!(certificate=?binding.certificate, "Binding key password");
            key_password.map(|key| {
                binding_encrypt(binding, key).with_context(|| {
                    format!(
                        "Failed to bind key password with {}",
                        &binding.certificate.display()
                    )
                })
            })
        })
        .collect::<Result<Vec<_>, _>>()?;

    // If no bindings are configured, the key is only encrypted with the user password
    if bound_passwords.is_empty() {
        let none_binding = key_password.map(|p| {
            let password = String::from_utf8(p.to_vec())?;
            Ok::<_, anyhow::Error>(BoundPassword::None { password })
        })?;
        bound_passwords.push(none_binding);
    }

    symmetric_encrypt(
        user_password,
        serde_json::to_vec(&bound_passwords)?.as_slice(),
    )
}

/// Implement a helper for unsigned, symmetrically encrypted data for Sequoia.
struct SymmetricHelper {
    password: Password,
}

// Decrypt exclusively via symmetrically encrypted session keys.
impl DecryptionHelper for SymmetricHelper {
    fn decrypt(
        &mut self,
        _pkesks: &[sequoia_openpgp::packet::PKESK],
        symmetric_session_keys: &[sequoia_openpgp::packet::SKESK],
        _sym_algo: Option<sequoia_openpgp::types::SymmetricAlgorithm>,
        decrypt: &mut dyn FnMut(
            Option<sequoia_openpgp::types::SymmetricAlgorithm>,
            &sequoia_openpgp::crypto::SessionKey,
        ) -> bool,
    ) -> sequoia_openpgp::Result<Option<sequoia_openpgp::Cert>> {
        for session_key in symmetric_session_keys {
            if session_key
                .decrypt(&self.password)
                .map(|(algorithm, session_key)| decrypt(algorithm, &session_key))
                .unwrap_or(false)
            {
                return Ok(None);
            }
        }
        Err(anyhow::anyhow!("Bad passphrase"))
    }
}

// A no-op verification helper implementation since the data is not expected to be signed.
impl VerificationHelper for SymmetricHelper {
    fn get_certs(
        &mut self,
        _ids: &[sequoia_openpgp::KeyHandle],
    ) -> sequoia_openpgp::Result<Vec<sequoia_openpgp::Cert>> {
        Ok(vec![])
    }

    fn check(
        &mut self,
        _structure: sequoia_openpgp::parse::stream::MessageStructure<'_>,
    ) -> sequoia_openpgp::Result<()> {
        Ok(())
    }
}

/// Encrypts some data with the given [`Password`] using GPG.
///
/// Returns the ASCII-armored, encrypted `key_passphrase`.
fn symmetric_encrypt(password: Password, data: &[u8]) -> anyhow::Result<Vec<u8>> {
    let mut buffer = vec![];
    {
        let message = Armorer::new(Message::new(&mut buffer)).build()?;
        let encryptor = Encryptor::with_passwords(message, Some(password))
            .symmetric_algo(SymmetricAlgorithm::AES256)
            .build()?;
        let mut message = LiteralWriter::new(encryptor).build()?;
        message.write_all(data)?;
        message.finalize()?;
    }

    Ok(buffer)
}

/// Decrypt data using GPG.
///
/// This is the inverse of [`symmetric_encrypt`]. Data is not expected to be signed and signatures are not checked.
fn symmetric_decrypt(password: Password, data: &[u8]) -> anyhow::Result<Vec<u8>> {
    let policy = StandardPolicy::new();
    let helper = SymmetricHelper { password };
    let mut decryptor = DecryptorBuilder::from_bytes(&data)?.with_policy(&policy, None, helper)?;
    let mut user_passphrase = vec![];
    decryptor.read_to_end(&mut user_passphrase)?;

    Ok(user_passphrase)
}

/// Encrypt some data using a [`Binding`] configuration.
///
/// The data is typically the password used to encrypt a private key.
///
/// The data is encrypted with the X509 certificate in the provided binding to a CMS (RFC 5652)
/// structure which is PEM-encoded. AES-256-GCM is used for the symmetric cipher.
fn binding_encrypt(binding: &Pkcs11Binding, data: &[u8]) -> anyhow::Result<BoundPassword> {
    let certificate = std::fs::read_to_string(&binding.certificate)?;
    let certificate = X509::from_pem(certificate.as_bytes())?;
    let mut cert_stack = Stack::new()?;
    cert_stack.push(certificate)?;
    let encrypted = CmsContentInfo::encrypt(
        &cert_stack,
        data,
        Cipher::aes_256_gcm(),
        CMSOptions::empty(),
    )?;
    let pem = encrypted.to_pem()?;
    let certificate = cert_stack.pop().expect("we just pushed a cert");
    let key_fingerprint = format!("{:X?}", &certificate.digest(MessageDigest::sha256())?);
    Ok(BoundPassword::Pkcs11WithCMS {
        key_fingerprint,
        password: String::from_utf8(pem)?,
    })
}

/// Decrypt a bound password using a PIN-protected private key in a PKCS11 token.
async fn binding_decrypt(binding: Pkcs11Binding, data: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let output = tokio::task::spawn_blocking(move || {
        let private_key = binding.private_key.as_ref().ok_or_else(|| {
            anyhow::anyhow!(
                "Binding configuration is missing the 'private_key' field and can't be used to decrypt"
            )
        })?;
        // In the future maybe we'll get openssl provider APIs? Alternatively, if Sequioa gets
        // PKCS#11 support, we could switch to using it in a migration.
        let mut command = std::process::Command::new("openssl");
        let mut child = command
            .args([
                "cms",
                "-decrypt",
                "-inform",
                "pem",
                "-provider",
                "pkcs11",
                "-passin",
                "stdin",
                "-inkey",
            ])
            .arg(private_key)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;
        let mut stdin = child
            .stdin
            .take()
            .ok_or_else(|| anyhow::anyhow!("openssl-cms command missing stdin"))?;

        binding.pin.ok_or_else(||anyhow::anyhow!("Binding must include a PIN"))?.map(|pin| {
            stdin.write_all(pin)
        })?;
        stdin.write_all(b"\n")?;
        stdin.write_all(&data)?;
        drop(stdin);

        let output = child.wait_with_output()?;
        Ok::<_, anyhow::Error>(output)
    }).await??;
    let stderr = String::from_utf8_lossy(&output.stderr);
    if !output.status.success() {
        return Err(anyhow::anyhow!(
            "Failed to decrypt data via PKCS#11 using openssl-cms (exited {:?}): {stderr}",
            output.status.code()
        ));
    }

    Ok(output.stdout)
}

#[cfg(test)]
mod tests {

    use anyhow::Result;
    use tempfile::NamedTempFile;

    use super::*;
    use crate::server::crypto::test_utils::setup_hsm;

    // Encrypting and then decrypting should give us the key back
    #[test]
    fn encrypt_decrypt() -> Result<()> {
        let user_passphrase = Password::from("this grants a user access to the key passphrase");
        let data = "this encrypts the private key";
        let encrypted_data = symmetric_encrypt(user_passphrase.clone(), data.as_bytes())?;
        let decrypted_data = symmetric_decrypt(user_passphrase, &encrypted_data)?;
        assert_eq!(data.as_bytes(), decrypted_data);
        Ok(())
    }

    // Ensure something encrypted with sq's CLI is decrypted by our implementation
    #[test]
    fn encrypt_with_sq_decrypt() -> Result<()> {
        let user_passphrase = "this grants a user access to the key passphrase".to_string();
        let data = "this encrypts the private key";
        let mut password_file = NamedTempFile::new()?;
        let mut message = NamedTempFile::new()?;
        password_file.write_all(user_passphrase.as_bytes())?;
        message.write_all(data.as_bytes())?;

        let mut command = std::process::Command::new("sq");
        let result = command
            .arg("encrypt")
            .arg(format!(
                "--with-password-file={}",
                password_file.path().display()
            ))
            .arg("--without-signature")
            .arg(message.path())
            .output()?;

        let retrieved_key_passphrase =
            symmetric_decrypt(Password::from(user_passphrase), &result.stdout)?;
        assert_eq!(data.as_bytes(), retrieved_key_passphrase);
        Ok(())
    }

    // Ensure something encrypted with our implementation is decryptable by sq's CLI
    #[test]
    fn encrypt_decrypt_with_sq() -> Result<()> {
        let user_passphrase = "this grants a user access to the key passphrase".to_string();
        let data = "this encrypts the private key";
        let encrypted_passphrase =
            symmetric_encrypt(Password::from(user_passphrase.as_bytes()), data.as_bytes())?;
        let mut password_file = NamedTempFile::new()?;
        let mut encrypted_message = NamedTempFile::new()?;
        password_file.write_all(user_passphrase.as_bytes())?;
        encrypted_message.write_all(&encrypted_passphrase)?;

        let mut command = std::process::Command::new("sq");
        let result = command
            .arg(format!(
                "--password-file={}",
                password_file.path().display()
            ))
            .arg("decrypt")
            .arg(encrypted_message.path())
            .output()?;
        assert_eq!(data.as_bytes(), result.stdout);

        Ok(())
    }

    /// Assert encrypting and then decrypting for bindings works.
    #[tokio::test]
    async fn encrypt_decrypt_binding() -> Result<()> {
        let softhsm = setup_hsm()?;

        let binding = softhsm.bindings.first().unwrap();
        let bound_password = binding_encrypt(binding, b"some data")?;
        let decrypted_data = match bound_password {
            BoundPassword::None { password: _ } => {
                panic!("We should have encrypted it with a certificate")
            }
            BoundPassword::Pkcs11WithCMS {
                key_fingerprint: _,
                password,
            } => binding_decrypt(binding.to_owned(), password.into_bytes()).await,
        }?;

        assert_eq!(b"some data".as_slice(), decrypted_data);

        Ok(())
    }

    /// Assert the complete encryption/decryption process roundtrips as expected.
    #[tokio::test]
    async fn encrypt_decrypt_key_password() -> Result<()> {
        let softhsm = setup_hsm()?;

        let key_password = Password::from("a secret that never leaves the server");
        let user_password = Password::from("some long password clients provide");
        let blob = encrypt_key_password(
            &softhsm.bindings,
            user_password.clone(),
            key_password.clone(),
        )?;
        let roundtrip_key_password =
            decrypt_key_password(&softhsm.bindings, user_password, &blob).await?;

        assert_eq!(key_password, roundtrip_key_password);

        Ok(())
    }

    // Assert if no bindings include keys, we get an error
    #[tokio::test]
    async fn encrypt_decrypt_key_password_binding_no_key() -> Result<()> {
        let softhsm = setup_hsm()?;

        let key_password = Password::from("a secret that never leaves the server");
        let user_password = Password::from("some long password clients provide");
        let blob = encrypt_key_password(
            &softhsm.bindings,
            user_password.clone(),
            key_password.clone(),
        )?;
        let result =
            decrypt_key_password(softhsm.bindings.get(1..).unwrap(), user_password, &blob).await;
        assert!(result.is_err_and(|err| err.to_string().contains("Unable to unbind key password")));

        Ok(())
    }

    // We should get an error if the user password is incorrect
    #[tokio::test]
    async fn encrypt_decrypt_key_password_wrong_user_password() -> Result<()> {
        let softhsm = setup_hsm()?;

        let key_password = Password::from("a secret that never leaves the server");
        let user_password = Password::from("some long password clients provide");
        let blob = encrypt_key_password(&softhsm.bindings, user_password, key_password.clone())?;
        let user_password = Password::from("the wrong password");
        let result =
            decrypt_key_password(softhsm.bindings.get(1..).unwrap(), user_password, &blob).await;
        let err_str = result.map_err(|e| e.to_string()).err().unwrap();
        assert_eq!(err_str, "User password is invalid");

        Ok(())
    }

    // Assert if no bindings are configured, just the user password is sufficient.
    #[tokio::test]
    async fn encrypt_decrypt_key_password_no_bindings() -> Result<()> {
        let key_password = Password::from("a secret that never leaves the server");
        let user_password = Password::from("some long password clients provide");
        let blob = encrypt_key_password(&[], user_password.clone(), key_password.clone())?;
        let roundtrip_key_password = decrypt_key_password(&[], user_password, &blob).await?;
        assert_eq!(key_password, roundtrip_key_password);
        Ok(())
    }
}
